= Example module

This module shows a few examples on how to create Puppet resources.

This README gives a short introduction, but you should also read at least
the beginners documentation from Puppetlabs. The link is in the end of this
README (4).


= Documentation

Documentation is done with rdoc. It can be generated on puppet server by
running 'puppet doc --mode rdoc'. This will output html docs to ./doc/ directory.

Documentation can then be viewed with 'links doc/index.html'

RDoc markup and document generation is explained in more detail in:
- http://projects.puppetlabs.com/projects/puppet/wiki/Puppet_Manifest_Documentation


= Module Basics

Puppet modules are a way to organize related code and data together. Each module
should be a self-contained object that can be used to deploy configuration
for an application, server role or other target.

All Puppet configuration should be in modules with the exception of site.pp.
Modules define the actual configuration and site.pp declares what modules are
used on each node.

Example site.pp
---
node p1-ss01 {
    # In basic case just list the modules this node uses.
    # Manaport and nagios modules are now initialized with
    # their default settings
    include manaport
    include nagios

    # Modules may accept parameters. Here clustering module
    # is initialized so that a specific peer host is named.
    # Note: cmanager stores these parameters in site data and
    # they are not initialized like this in the final version.
    # This is the normal Puppet way to do things and it
    # can be used while testing.
    include clustering {
        peer => 'p1-ss02',
        ...
    }
    ...
}
---
Modules are stored in /etc/puppet/modules/ directory where each module is in
its own subdirectory. Command 'puppet module' can be used to search and install
3rd party modules from internet. 3rd party modules can be used for learning or
as a basis for new modules. Note that the quality of these modules vary a lot.
The modules created by Puppetlabs are usually good quality.

= Module Structure

Each module contains a bunch of subdirectories that contain specific data:
 * manifests/
   - This directory has .pp manifest files. The main manifest must be init.pp and it
     contains a class that has the same name as the module. Other classes, defines, etc
     can be defined in other .pp files. Naming convention is that class my_module::foo
     is in foo.pp.
     Subdirectories can be created. In that case class my_module::foo::bar is
     defined in manifests/foo/bar.pp.
 * templates/
   - Here are templates for files generated by Puppet. These use erb syntax for
     inserting data values to the generated file. A template can refer to any
     variable currently in scope (variables in modules .pp files, variables for
     this node).
     Templates are realized from manifests with function template()
     For example: template('my_module/foo.erb') would render file templates/foo.erb.
 * files/
   - These are static files served by Puppet. The file in this directory is not manipulated
     at all -> target host will receive exact same file.
 * lib/
   - This directory contains plugins for Puppet. This is more advanced usage and
     most modules probably do not include anything under lib/.
 * lib/puppet/parser/functions/
   - Plugin functions to Puppet parser. These are run on Puppet server while
     compiling node catalogs.
 * lib/puppet/provider/
   - Providers are used to realize Puppet configuration. For example 'package' type
     can be used to define a list of packages that are installed on host. Only package
     names need to be defined, but the type works automatically on RPMs, DEBs etc.
     In this case the type has providers for yum, apt-get, etc. and the provider is
     automatically selected based on operatingsystem fact.
 * lib/puppet/type/
   - New types are stored here. These will extend the DSL so that you can use the
     new types in .pp manifests:
     mytype { 'foo':
         param1 => 'bar',
         param2 => 'baz',
     }
     New types are used just like native ones (for example file, host or package).
 * lib/facter/
   - Scripts that query values from a host. These will be run by facter on the actual
     host. The results can then be used in manifests just like native facts.
 * tests/
   - This directory contains .pp files that show how this module can be used.
     These manifests will create instances of all classes, resources, types, etc. that
     this module provides. The manifests can be used as unit tests or just examples.
     Each .pp file should be usable with 'puppet apply' command.
 * spec/
   - This directory contains tests for extensions in lib/ directory. RSpec tool
     is used to run these. 
 * Modulefile
   - This file contains module metadata. It includes module name, author, version,
     dependencies to other modules etc. Module works fine without this, but its
     nice to have.

Command 'puppet module generate platform-module' will create an example module
to directory ./platform-module. 


= Generating Files from Multiple Sources

In some cases a configuration file must be accessed from a number of modules.
One solution would be to have one module control the file and provide a defined
type for adding lines or specific sections to the file.

Probably best solution is to use Augeas. It's specifically designed to generate
files from snippets. For examples using Augeas install module domcleal-augeasproviders


= Best Practices

All targets that a module manages should be related and the module should be as
self-contained as possible.

Do not reference files or templates from other modules

Main class of the module should be parametrized and parameters should be
queried from site data. This way site.pp must only find out what modules
are included for each host.

Always refer to variables using their full scope. For example:
    # correct
    foo = $my_module::my_var
    # wrong
    foo = $my_var


= Further Reading

1. Basic module structure and other info (plenty of overlap with this README). 
   http://docs.puppetlabs.com/puppet/3/reference/modules_fundamentals.html

2. Puppet API. Type and function references are relevant for module creation.
   http://docs.puppetlabs.com/references/3.0.0/

3. Puppetlabs style guide. Follow this unless theres a good reason not to.
   http://docs.puppetlabs.com/guides/style_guide.html

4. Puppetlabs beginners documentation
   http://docs.puppetlabs.com/learning/




